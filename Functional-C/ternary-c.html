<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Ternary C</title>
  <style>
    article { width: 40em; margin: auto; }
    h1  { font-size: 200%;
          margin: 0;
          padding-left: 0; padding-right: 0; padding-top: 0.25em; padding-bottom: 0.25em;
        }
    h2  { font-size: 150%;
          margin: 0;
          padding-left: 0; padding-right: 0; padding-top: 0.25em; padding-bottom: 0;
        }
    h3  { font-size: 150%;
          margin: 0;
          padding-left: 1em; padding-right: 0; padding-top: 0.25em; padding-bottom: 0.25em;
        }
    hr { width: 25em; }
    a { text-decoration: none; }
    div { margin-top: 0; margin-bottom: 0.5em;
          padding-left: 1em; padding-top: 0em; padding-bottom: 0em; padding-right: 1em;
        }
    pre { margin-top: 0; margin-bottom: 0em;
          padding-left: 1em; padding-top: 0em; padding-bottom: 0em; padding-right: 1em;
        }
    p { margin-bottom: 1em; margin-top: 1em; margin-left: 0; margin-right: 0;
        padding: 0;
      }
    table { margin: auto; }
    .figure { display: block; margin: auto; }
    footer { margin-bottom: 1em; margin-top: 1em; margin-left: 0; margin-right: 0; }
    .C { font-family: monospace; white-space: pre; }
    .nowrap { white-space: nowrap; }
    .highlight { color: red; }
    .highlight-done { color: blue; }
    .blockquote { padding-left: 2em; padding-right: 2em; font-style: italic; }
  </style>
</head>
<body>
<article id="top">
<h1>Ternary C</h1>
<p> The <a href="./classical-c.html">previous essay</a> argues the functional
  connectives in C <span class="nowrap">{&rarr;, **, &#8612;}</span>
  are paired with classical logic rather than intuitionistic logic
  and, along with other connectives
  <span class="nowrap">
    {<span class="C">void</span>, <span class="C">NULL</span>, !, &times;, &amp;, ;}
  </span>
  help keep valid program state.
  The <a href="./index.html">next prior essay</a> had introduced these
  connectives in terms of boolean algebra with classical truth propositions,
  <ul>
    <li>T &equiv; <em>the object exists at the referenced location and follows its type (1)</em></li>
    <li>F &equiv; <em>the object does not exist, does not fit its type (3), or has zero type information (2)</em></li>
  </ul>
</p>
<p> Part of what makes C so interesting is how True and False were hacked
  together. To represent true and false, C has two idempotent symbols,
  <span class="C">void</span> and <span class="C">NULL</span>.
</p>
<ol>
<li>
<p> The <span class="C">void</span> object is
  special since <em>it is always true because its size is zero</em>,
  and we say its only enumerable value is 1. Any type unioned or crossed with
  <span class="C">void</span> (or crossed by another enumerated tag) is
  interpreted as storing the exact same set of information.
  <div class="C">
    (int &amp; 1) a, (int &times; 1) b, (int &times; 2) c;
    a &lt;-+ 0x0f;                // a = 15
    b &lt;-+ a;                   // b = 15
    c &lt;-+ b;                   // c = 15
  </div>
</p>
</li>
<li>
<p> To generate the vacuously false case
  <em>the object has zero type information</em>, C uses indirection
  towards the trivially true case. Thus
  <span class="C">*void malloc(size_t)</span> can be used to provide memory for
  any type of object.
  <div class="C">
    Compl = (real, imag) &isin; Float &times; Float;
    *Float r1 &lt;-+ malloc(sizeof(r1));
    *Compl c1 &lt;-+ malloc(sizeof(c1));
  </div>
</p>
</li>
<li>
<p> A <span class="C">NULL</span> object is one <em>that does not exist or does
  not follow its type</em>, and this false proposition is idempotent for
  exclusive-or types like pointers,
  <span class="nowrap">a ** b &equiv; (&not;a &oplus; a * b)</span>.
  <div class="C">
    intptr ** Obj_type a;
    a &lt;-+ NULL;                // a may be NULL
    a &lt;-+ malloc(sizeof(a));   // or a valid reference
  </div>
</p>
</li>
</ol>
<p> This essay experiments with splitting this binary system into a
  ternary type system.
</p>
<hr>
<p> We can embed the existing binary logic in a balanced ternary scheme by
  merging <span class="C">NULL</span> and <span class="C">*void</span>
  into a single concept of False, which is the
  negation of True. However between them is a sentinel
  <span class="C">()</span>, understood to signal the possibility of a
  runtime null.
</p>
<table>
  <tr>
    <th>T</th><td>true</td><td class="C">(void)</td><td></td><td></td>
  </tr><tr>
    <th>F</th><td>runtime false</td><td class="C">(NULL)</td><td>or compile time false <span class="C">(*void)</span></td>
  </tr><tr>
    <th></th><td>&darr;</td><td>&darr;</td><td>&darr;</td>
  </tr><tr>
    <th>T</th><td>enumerated true</td><td>(<span class="C">void</span>)</td>
  </tr><tr>
    <th>0</th><td>unknown</td><td></td><td>(forces runtime testing of enumerated truth)</td>
  </tr><tr>
    <th>F</th><td>false</td><td>(<span class="C">*void</span>)</td><td>(<span class="C">NULL</span>)</td>
  </tr>
</table>
<table>
<tr>
  <th>a</th><th>b</th><td>|</td><th>+</th><th>&times;</th><th>&</td><th>&oplus;</th><th>&rarr;</th><th>a+&not;b</th>
  <th>b&oplus;a&oplus;b</th><th>(a&larr;b)&times;(a&larr;&not;b)</th>
</tr><tr>
  <td>T</td><td>T</td><td>|</td><td>T</td><td>T</td><td>T</td><td>F</td><td>T</td><td>T</td><td>T</td><td>T</td>
</tr><tr>
  <td>T</td><td>0</td><td>|</td><td>T</td><td>0</td><td>0</td><td>0</td><td>0</td><td>T</td><td>0</td><td>T</td>
</tr><tr>
  <td>T</td><td>F</td><td>|</td><td>T</td><td>F</td><td>F</td><td>T</td><td>F</td><td>T</td><td>T</td><td>T</td>
</tr><tr>
  <td>0</td><td>T</td><td>|</td><td>T</td><td>0</td><td>0</td><td>0</td><td>T</td><td>0</td><td>0</td><td>0</td>
</tr><tr>
  <td>0</td><td>0</td><td>|</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
</tr><tr>
  <td>0</td><td>F</td><td>|</td><td>0</td><td>F</td><td>0</td><td>0</td><td>0</td><td>T</td><td>0</td><td>0</td>
</tr><tr>
  <td>F</td><td>T</td><td>|</td><td>T</td><td>F</td><td>F</td><td>T</td><td>T</td><td>F</td><td>F</td><td>F</td>
</tr><tr>
  <td>F</td><td>0</td><td>|</td><td>0</td><td>F</td><td>0</td><td>0</td><td>T</td><td>0</td><td>0</td><td>0</td>
</tr><tr>
  <td>F</td><td>F</td><td>|</td><td>F</td><td>F</td><td>T</td><td>F</td><td>T</td><td>T</td><td>F</td><td>F</td>
</tr>
</table>

<hr>
<footer>
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
    <img alt="Creative Commons License" style="border-width:0"
    src="https://i.creativecommons.org/l/by/4.0/80x15.png" />
  </a> Ben Lorenzetti<br />
  This work is licensed under a
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
    Commons Attribution 4.0 International License
  </a>.
</footer>
</article>
</body>
</html>
