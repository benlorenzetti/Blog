<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8"/>
	<title>BL's Blog</title>
	<link rel="stylesheet" type="text/css" href="../Branding/home.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
    </script>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2647559998401134",
            enable_page_level_ads: true
        });
    </script>
</head>

<body>
<div id="horizontal-div-containing-entire-page">
<header></header>
<aside>
<a href="../index.html"><img src="ooop-fp.jpg" alt="Brand" width="300px;"></a>
</aside>
<div id="vertical-div-containing-article-and-navigation">
<article>
<h1>Operation-Oriented, Functional C</h1>
<h2>25 MAR 2019</h2>
<p> I don't drink the coolaid (&rarr; failed programming
    paradigms in college), yet now I find myself proselytizing
    functional features for a better C.
    Turns out coolaid is a drink you make yourself, so what is functional
		programming?
</p>
<p> Any decent functional language ought to support infix operators
	(C++ partially improves C in this regard). For example,
	<span class="code">(a + b) + (c + d)</span> should be equivalent to
  <span class="code">+(+(a, b), +(c,d))</span>. Regardless of parenthesization,
	the function must be <em>unambiguously identified</em> at the call site.
	Further, parenthesis should often be unnecessary.
</p>
<p> Function signatures should evoke an evaluation order;
  expressions should build that order. For example <em>binary operations</em>
	(a subset of functions) like
  addition <span class="code">+: U32 &times; U32 &rarr; U32</span> should
	alternate associativity, such that the default parsing of
	<span class="code">a + b + c + d</span> is
</p>
<img alt="[add-abcd.png]" src="add-abcd.png" width="80%;" style="margin-left:10%;">
<p>
  i.e. odd-indexed binary operators bind closer and are evaluated first,
	and <em>the usual functional evaluation order is bottom-up</em>.
</p>
<p> Piggybacking on this, many new functional languages emphasize bottom-up
	immutability, but what makes C timeless is certain expressions are
	<em>evaluated top-down</em>, in particular memory address calculations and
	memory loads can be reversed to store data and update the
	global memory map, which is the one <em>unambigous, anonymous</em>
	lambda function.
</p>
<p> I plan to write more about this lambda function
	<span class="code">&lambda;: u64 &rarr; u64</span>,
	<a href="references.html">basically C's *dereference operator</a>,
	but for now, if the generic concept of pointers is the universal
	anonymous function, then we can add <em>implication</em> &rarr; to our expressions
	and <em>assert top-down statements of truth</em>.
	(<span class="code">if () then {}</span> conditionals fit nicely in
	this framework as well.)
</p>
<p> So what is the functional paradigm really? I think it is a convenient syntax
	for writing expressions and a composable semantics of object propositions
	with functions as logical implications.
</p>
<footer>
<hr>
<p> Views expressed are those of Mr. Lorenzetti,
not the Department of Defense.
</p>
</footer>
</article>
<nav>
    <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="../About/index.html">About</a></li>
        <li><a href="../Archive/index.html">Archive</a></li>
    </ul>
    <div style="clear: both; min-width: 100%; margin: 0px; padding: 0px;"></div>
</nav>
</div><!--article+nav wrapper-->
<footer></footer>
</div><!--horizontal centering div-->
</body>
</html>
