<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Functional C</title>
  <style>
    article { width: 40em; margin: auto; }
    hr { width: 25em; }
    a { text-decoration: none; }
    div { margin-top: 0; margin-bottom: 0.5em;
          padding-left: 1em; padding-top: 0em; padding-bottom: 0em; padding-right: 1em;
        }
    p { margin-bottom: 1em; margin-top: 1em; margin-left: 0; margin-right: 0;
        padding: 0;
      }
    table { margin: auto; }
    footer { margin-bottom: 1em; margin-top: 1em; margin-left: 0; margin-right: 0; }
    .C { font-family: monospace; white-space: pre; }
    .nowrap { white-space: nowrap; }
  </style>
</head>
<body>
<article>
<h1>Functional C</h1>
<p> The big idea of functional programming is that data types and
  functions in programs are like propositions and implications in logic
  proofs, and that this correspondence is a good way to organize language semantics.
  This essay explores the "functional" semantics
  of the C Programming Language, anticipating how they could be expanded to a
  system inspired by Girard's

</p>
<p> A separate idea, which I call operation-oriented programming, is often
  conflated with functional programming. Operations are functions of the form
  <span class="nowrap">T &times; &middot;&middot;&middot; &times; T &rarr; T</span>
  for some type T. For example:
  <div class="C">
    struct complex { float real; float imag; };
    struct complex a, b;
    struct complex mul(struct complex c1, struct complex c2);
  </div>
  The function <span class="C">mul</span> is an operation on complex numbers,
  so for operation-oriented programming we might write
  <span class="C">mul a b</span> or
  <span class="C">a mul b</span> instead of
  <span class="C">mul(a, b)</span>.
  Since operations &sube; functions, its easy to see how the conflation arises
  and its not such a bad con; I will happily use this "functional" syntax as
  if C could do it.
</p>
<hr>
<p> A nice basis for Boolean algebra is one unary
  plus two binary operators, operating on the set of values
  <span class="nowrap">&Bopf; = {T, 0}</span> storable in a single bit
  or a subspace of a word in memory. The binary operators have the type
  signature
  <span class="nowrap">&Bopf; &times; &Bopf; &rarr; &Bopf;</span>
  so their cardinality is
  <span class="nowrap">|&Bopf;|^|&Bopf;&times;&Bopf;| = 2^(2*2) = 16</span>,
  i.e. there are 16 possible binary operators. For
  <span class="nowrap">unary &Bopf; &rarr; &Bopf;, there are 2^(2)</span>
  possible: negation, buffer, always zero, and always true.
  Three basis plus two more of the 16 possible operations are also listed in
  the table below.
</p>
<table>
  <tr>
    <th>Operation</th>
    <th>Example</th>
    <th></th>
    <th>Assembly</th>
    <th>Functional C</th>
  </tr><tr>
    <td>Negation</td>
    <td>&not;a</td>
    <td>T if a = 0</td>
    <td class="C">INV</td>
    <td class="C"></td>
  </tr><tr>
    <td>Disjuction</td>
    <td>a + b</td>
    <td>T if a = T or b = T (min function)</td>
    <td class="C">OR</td>
    <td class="C"></td>
  </tr><tr>
    <td>Conjunction</td>
    <td>a &times; b</td>
    <td>T if a = T and b = T (max function)</td>
    <td class="C">AND</td>
    <td class="C">struct</td>
  </tr><tr>
    <td>Exclusive Disjunction</td>
    <td>a &oplus; b</td>
    <td>(a &times; &not;b) + (b &times; &not;a)</td>
    <td class="C">XOR</td>
    <td class="C">union</td>
  </tr><tr>
    <td>Logical Implication</td>
    <td>a &rarr; b</td>
    <td>&not;a + b</td>
    <td class="C"></td>
    <td class="C">functions</td>
  </tr>
</table>
<p> The last two hint at how all 16 possible operations can be constructed
  algebraically from the basic three, given two propositions (a and b) that could
  be either true (T) or false (0). This is classical logic, and in the sense of
  functional programming, the propositions are
  <em>that an object fits a known type and it exists in memory</em>.
  Finally, any three of the 16 operations could be chosen as bases and
  more than three can be offered as intrinsic/built-in.
</p>
<hr>
<p> I claim that C already has five functional connectives built into the
  language: &times;, &oplus;, &rarr;, &#8612;, and ";" or structure, union,
  function, store, and statement. The connectives operate on the
  proposition that all objects follow their type once they are born.
  The compiler operates on the predicate that every statement the programmer
  makes is truth (T).
  But to explore this further we need the truth tables.
</p>
<table border="0" cellspacing="0" cellpadding="2em">
  <tr>
    <th>a</th>  <th>b</th>  <th>|</th>  <th>&times;</th>  <th>&oplus;</th>  <th>&rarr;</th> <th>&#8612;</th>  <th>;</th>
  </tr><tr>
    <td>0</td>  <td>0</td>  <td>|</td>  <td>0</td>        <td>0</td>        <td>T</td>      <td>0</td>        <td>T</td>
  </tr><tr>
    <td>0</td>  <td>T</td>  <td>|</td>  <td>0</td>        <td>T</td>        <td>T</td>      <td>0</td>        <td>T</td>
  </tr><tr>
    <td>T</td>  <td>0</td>  <td>|</td>  <td>0</td>        <td>T</td>        <td>0</td>      <td>T</td>        <td>T</td>
  </tr><tr>
    <td>T</td>  <td>T</td>  <td>|</td>  <td>T</td>        <td>0</td>        <td>T</td>      <td>T</td>        <td>T</td>
  </tr>
</table>
<ol>
  <li><h2>"times"</h2>
<p> The first operator &times;, called <em>and</em> in classical logic,
  <em>times</em> in Girards' logic, and <span class="C">struct</span> or
  <em>arguement list</em> in Richie's, allows us to define a larger object
  type in memory from a concatenation of smaller ones, corresponding to a cross
  product of the state spaces of the substructs. For example the
  <span class="C">struct</span> type
  <span class="C">char &times; char</span> has
  <span class="nowrap">|char|*|char| = 256*256</span> possible values.
</p>
<div class="C">
  struct shortint { char high; char low; };
</div>
<p>
  From the truth table we see that an object of type A&times;B is only true if
  both its parts a and b exist in memory and follow their respective types.
  We add the additional notion that they are adjacent in memory.
  It is unfortunate in C that structures and arguement lists cannot be conflated.
</p>
</li>
<li><h2>"xor"</h2>
<p> The second operator &oplus;, called <em>exclusive or</em>, <em>plus</em>,
  or <span class="C">union</span> has the meaning in C that this block of
  memory could be interpreted as either type A or type B, but the
  compiler has no idea which one is correct. In set space, its cardinality
  is probably <span class="nowrap">|A&oplus;B| = |A| + |B|</span>, like the
  disjoint union of sets, but we rarely actually care to calculate the
  cardinality of our types so specifying this seems unproductive. It is
  unfortunate in C that the union type cannot have any nominal intersection
  of substructures.
</p>
</li>
<li><h2>"functional imp"</h2>
<p> The case for functions is more nuanced, so we reach for the truth
  table. If a function <span class="C">mul</span> has type
  <span="nowrap">mul: &Copf;&times;&Copf;&rarr;&Copf;</span>, then we must
  first determine (or indeed select <span class="C">mul</span> based on) if
  an object <span class="C">(a1, a2]</span> exists in memory and has type
  <span class="nowrap">&Copf;&times;&Copf;</span>.
  You would have already asserted this is true (T) with
  <div class="C">
    struct complex a1 = {.real = 0.6, .imag = 0.8};       a b | a&rarr;b
    struct complex a2 = {.real = 1, .imag = 0 };          0 0 | T
    struct complex b;                                     0 T | T
                                                          T 0 | 0
    b = mul(a1, a2);                                      T T | T
  </div>
  i.e. by declaring, initializing, and <em>listing</em> <span class="C">c1</span>
  and <span class="C">c2</span>. The compiler will typically use a case from the
  truth table that makes the expression <span class="C">mul(a1, a2)</span> T.
  Thus, if the arguement list
  <span class="nowrap">a &isin; &Copf; &times; &Copf;</span> type checked T,
  then the standard behaviour is a proof the result 'b' exists with the proper
  type &Copf;.
</p>
<p> Otherwise, if the result object is false (0) then the entire expression
  evaluates false, possibly signaling a logic error, which would
  be the desired compiler behaviour if we think
  <span class="C">fprintf(stdout, "Good")</span> is semantically superior to
  <span class="C">printf("Bad")</span>.
  Bjarne Stroustrup already improved C in this regard by introducing
  input output streams.
</p>
<p> The other cases <span class="nowrap">0 &rarr; 0 and 0 &rarr; T</span>
  will be discussed later.
</p>
</li>
<li><h2>"store"</h2>
<p> The most hackily-conjucted connective <em>store</em> (&#8612;),
  called <em>assignment</em> in C, is a conjuction of two logical operators:
  type implication (&larr;) and object aliasing (+).
</p>
<table border="0" cellspacing="0" cellpadding="2em">
  <tr>
    <th>b</th>  <th>a</th>  <th>|</th>  <th>&#8612;</th>  <th>|</th>  <th>&larr;</th> <th></th>         <th>+</th>
  </tr><tr>
    <td>0</td>  <td>0</td>  <td>|</td>  <td>0</td>        <td>|</td>  <td>T</td>      <td>&times;</td>  <td>0</td>
  </tr><tr>
    <td>0</td>  <td>T</td>  <td>|</td>  <td>0</td>        <td>|</td>  <td>0</td>      <td>&times;</td>  <td>T</td>
  </tr><tr>
    <td>T</td>  <td>0</td>  <td>|</td>  <td>T</td>        <td>|</td>  <td>T</td>      <td>&times;</td>  <td>T</td>
  </tr><tr>
    <td>T</td>  <td>T</td>  <td>|</td>  <td>T</td>        <td>|</td>  <td>T</td>      <td>&times;</td>  <td>T</td>
  </tr>
</table>
<p> Because C allows objects to be recycled in space and time,
  every connective is asserted twice: once before an expression is
  evaluated and again after. The statement
  <span class="C">b &#8612; a;</span>, for propositions
  <span class="nowrap">a, b &isin; A</span> is first an implication (&larr;)
  that
  <em>if a is an object with memory layout of type A, then so is b.</em>
  After this expression is evaluated true by the compiler, then it is an
  assertion that <em>b or a are equivalent objects with a</em> (with, in
  Girard's sense).
</p>
<p> As Girard's paper on
  <a href="http://girard.perso.math.cnrs.fr/Synsem.pdf">linear logic</a>,
  points out, we can think of OR like a symmetric implication;
  i.e. even if the object on one side dissapears (becomes 0), then the other
  object is still valid (T).
  <div>
    a + b &equiv; (&not;a &rarr; b) &equiv; (&not;b &rarr; a)
  </div>
  In this context, C's use of a symmetric operator <span class="C">=</span> for
  "store" is very insightful, although ultimately I agree with
  C++ and Alexander Stepanov that specified, non-symmetric
  semantics are needed and it shouldn't have been the symbol that means equality.
</p>
<p> Thus the logic expression for "store" can be written
  <div>
    b &#8612; a &equiv; (b &larr; a) &times; (b &larr; &not;a)
  </div>
  which signifies the possibility of a's memory being recycled after the store.
</p>
<p> More significantly, the logic expression for "procedural impl"
  can be written
  <div>
    a &rarr; b &equiv; (a &rarr; b) &times; (a &rarr; b)
  </div>
  which is also tautologically stupid but gives us a possible interpretation
  for the two cases of &rarr; not discussed above: that arguments
  passed to a function on the stack may become unavailable (a = 0) after
  the procedure returns.
</p>
</li>
<li>
  <h2>"statement"</h2>
</li>
<hr>
<h2>Functional C</h2>
<p> The C programming language has fundamentally functional semantics,
  including connective features
  <span class="C">struct</span>, <span class="C">union</span>,
  functions, assignments, and statements, or
  <span class="nowrap">&times;, &oplus;, &rarr;, &#8612;, and ';'</span>.
  However, in using these functional features, there is friction
  from C's syntax and its depth of analysis of structures, unions, and function
  types.
</p>
<p> Finally, most functional programming languages take their emphasis on
  functions one or two steps further than C, by emphasizing a few special functions
  that can <em>operate</em> on the abstract syntax tree and generic types at
  compile time (macros) or by emphasizing all proceedures should be proper
  mathematical functions (no side effects).
</p>
<p> Giving special status to a subset of functions seems useful (macros), but
  restricting the set of procedures to a subset of functions seems unproductive
  (no side effects). A <span class="C">time()</span> procedure with type
  <span class="nowrap">0 &rarr; &Zopf; &times; &Zopf;</span> trivially passes the
  logic test for implication, despite returning a different result each time
  called.
  Less obvious is whether it should be possible to use procedures of type
  <span class="nowrap">T &rarr; 0</span> with double negation, i.e. stating that
  <a href="./printf-implies-nothing.html">fprint implies nothing.</a>
</p>
<hr>
<footer>
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
    <img alt="Creative Commons License" style="border-width:0"
    src="https://i.creativecommons.org/l/by/4.0/80x15.png" />
  </a> Ben Lorenzetti<br />
  This work is licensed under a
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
    Commons Attribution 4.0 International License
  </a>.
</footer>
</article>
</body>
</html>
