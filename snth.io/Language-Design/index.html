Resources:

J.W.J. Williams and R.W. Floyd - heapsort and inplace, for beauty in
connectiong data structures and algorithms.

Alexander Stepanov - beauty in matching data structures and algorithms
in STL. On separating data and algorithms (theres a quote on this).
On type system and sytax for recomposibility in Elements of Programming
and semantic model of machine. Abstract from bottom up quote, related to
binary, ternary, quaternary logic.

Girard - idea of linear logic.

Dennis Richie - design of language by building a system.

Paul Graham and McCarthy - powerful communication in English, two types of
hackers, Lisp vs memory layout hackers. Main idea is about different macro
models (which are fundamentally a syntax thing) between a top level,
text substitution (UNIX), or type templating. Language as a way of thinking.

Dijstra - unafraid to think and have opinion on things. I disagree about 0.

Andrei Alexdrescu - good writing and stumbling on powerful, broadly applicable
data layout abstractions.

Napoleon - similarities with other human endeavors.

Meta Intro:

Language is the greatest enduring legacy of civilization. English. Latin.
Zero in math. Math and physics. SI. Turing bit representation. 
Programming languages. Tool of thought. Network effect. A language is
its history, its current semantics and sytax, and the number-ability-and-power
of those who speak it.

Human mind is the best parser. - Dennis Richie. What does well formed mean?

match current machine model - address by bit, not byte? little-endian, 2s 
compliment.

easy transistion from C.

Obey networking effects. big endian on networks. Little in math. sequence
indexing. Defer to common usage when you aren't sure. Don't defer when
you are certain.

Intro:

Alexander Stepanov on purpose of programming. (Represent real world in bits)
And programming language should give access to bits

A programming language comes down to two things: syntax and semantics; and
the programmer's mental model also comes down to two things: data/memory
layout and procedures on that data. Every effort should be made to have
consistency between language syntax, language semantics, and the mental model
of the machine. We should look critically
at machine models which complicate language semantics and syntax, and likewise 
at syntax and semantics which restrict use of machine features.

I believe the popularity and success of C is due to its enduring semantic
consistency with machine architectures (in a sense they have coevolved) and
its terse and flexible syntax which allows powerful (if difficult) textual
substitution macros.

The ambition of CTL is to largely preserve C's semantic machine model (with
a several modifications to reduce ambiguity) but redefine C's syntax and
rewrite the standard library in order to support AST modification macros
like the various LISPs and a generic type system.

Changes from C's Semantic Model:
1) N and U 2's compliment intrinsic types and arrays
2) Only little endian machines
3) Alignment requirements?
4) Support for ternary machines?
5) Emphasis on bounded ranges and safe iterators
6) Linear logic

Changes from C's Syntax:
1) bracket notation for pointer dereference
2) more "typey" "functional" syntax
3) built in collection library inspired by C++ STL
4) New string library
5) Linear logic functions and types improving function call interfaces
6) consistent bracing for different types of memory
7) A well specificed type-system top level for the compiler
8) unicode support

Highlighted non-changes:
1) Similar algebraic type system with structs, unions, and casting polymorhism
2) No language support for runtime varients/discriminated unions (use sentinels)
3) No language level garbage collection or dynamic object dispatch
4) No language level exceptions
5) No RAII; manual memory management for the heap
6) No namespaces separate from control flow / include file scoping
7) Pointers still present through type functions

Improving the semantic model through linear types.
Programming false dichotomies at language level
Object-oriented vs datum orientented
Functional vs Procedural
both of these are really about managing explosion of state in data or time
(time := control flow state).
Or about memory management in the heap vs function call stack.
